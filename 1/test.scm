;Code based on Exercise 4.24 from SICP:
;  Design and carry out some experiments to compare the speed of the original metacircular evaluator with the version in this section. 
;  Use your results to estimate the fraction of time that is spent in analysis versus execution for various procedures.

;The following is my solution:
;=========================================================
(define (true? x)
  (not (false? x)))

;==============GENERATE ARGUMENTS==============
;param_types:n n!=0 n<0 n<=0 n>0 n>=0 P L x ...

(define (mod-eq u x v n)
  (modulo (+ (* u x) v) n))

(define (greatest-smaller-odd a)
  (let ((next (- a 1)))
    (if (= (remainder next 2) 1)
      next
      (greatest-smaller-odd next))))


(define (make-numgen lower upper)
  (let ((rand_init (max 1 lower)))
    (let ((v (greatest-smaller-odd (+ upper 1))))
      (let ((u (greatest-smaller-odd v)))
        (define (update)
          (set! rand_init (+ lower (mod-eq u rand_init v (+ (- upper lower) 1)))))
        update))))

(define (n>=0-gen)
  (make-numgen 0 100))
(define (n>0-gen)
  (make-numgen 1 100))
(define (n<0-gen)
  (let ((ng (make-numgen 1 100)))
    (let ((rand_init (- (ng))))
      (define (update)
        (set! rand_init (- (ng))))
      update)))
(define (n-gen)
  (let ((ng (n>=0-gen))
        (-ng (n<0-gen))
        (ig (n>0-gen)))
    (let ((rand_init (ng)))
      (define (update)
        (if (eq? (remainder (ig) 2) 0)
          (set! rand_init (ng))
          (set! rand_init (-ng))))
      update)))

(define (n!=0-gen)
  (let ((ng (n>0-gen))
        (-ng (n<0-gen))
        (ig (n>0-gen)))
    (let ((rand_init (ng)))
      (define (update)
        (if (eq? (remainder (ig) 2) 0)
          (set! rand_init (ng))
          (set! rand_init (-ng))))
      update)))
(define (20<n<25-gen)
  (make-numgen 20 25))

(define (num->symbol num)
  (cond ((eq? num 0)
         (list 'quote 'a))
        ((eq? num 1)
         (list 'quote 'b))
        ((eq? num 2)
         (list 'quote 'c))
        ((eq? num 3)
         (list 'quote 'd))
        ((eq? num 4)
         (list 'quote 'e))
        ((eq? num 5)
         (list 'quote 'f))
        ((eq? num 6)
         (list 'quote 'g))
        ((eq? num 7)
         (list 'quote 'h))
        ((eq? num 8)
         (list 'quote 'i))
        ((eq? num 9)
         (list 'quote 'j))
        ((eq? num 10)
         (list 'quote 'k))
        ((eq? num 11)
         (list 'quote 'l))
        ((eq? num 12)
         (list 'quote 'm))
        ((eq? num 13)
         (list 'quote 'n))
        ((eq? num 14)
         (list 'quote 'o))
        ((eq? num 15)
         (list 'quote 'p))
        ((eq? num 16)
         (list 'quote 'q))
        ((eq? num 17)
         (list 'quote 'r))
        ((eq? num 18)
         (list 'quote 's))
        ((eq? num 19)
         (list 'quote 't))
        ((eq? num 20)
         (list 'quote 'u))
        ((eq? num 21)
         (list 'quote 'v))
        ((eq? num 22)
         (list 'quote 'w))
        ((eq? num 23)
         (list 'quote 'x))
        ((eq? num 24)
         (list 'quote 'y))
        ((eq? num 25)
         (list 'quote 'z))
        (else (error "Unrecognized number" num))))

;generate symbol
(define (s-gen)
  (define ng (make-numgen 0 25))
  (let ((rand_init (num->symbol (ng))))
    (define (update)
      (set! rand_init (num->symbol (ng))))
    update))

;generate predicates of the form (lambda (x) (< x n)), for n a number.
(define (lambda-helper relation elt)
  (make-lambda '(x) (list relation 'x elt)))
(define (pn-gen)
  (define ng (n-gen))
  (let ((rand_init (lambda-helper '<  (ng))))
    (define (update)
      (set! rand_init (lambda-helper '< (ng))))
    update))

;generate predicates of the form (eq? s1 s2), for s1,s2 symbols.
(define (ps-gen)
  (define sg (s-gen))
  (let ((rand_init (lambda-helper 'eq? (sg))))
    (define (update)
      (set! rand_init (lambda-helper 'eq? (sg))))
    update))

;generate predicates
(define (p-gen)
  (define pn (pn-gen))
  (define ps (ps-gen))
  (define ng (n-gen))
  (let ((rand_init (ps)))
    (define (update)
      (if (= (remainder (ng) 2) 0)
        (set! rand_init (pn))
        (set! rand_init (ps))))
    update))

;generate lists of numbers
(define (ln-gen)
  (define ng (make-numgen 0 1000))
  (let ((rand_init (list (ng))))
    (define (update)
      (set! rand_init (cons (ng) rand_init)))
    update))

(define (ln-gen-pre)
  (define ng (n-gen))
  (let ((rand_init (ng)))
    (define (update)
      (set! rand_init (ng)))
    update))

;generate list of numbers, symbols, and predicates
(define (ln-gen . n)
  (let ((lngp (ln-gen-pre)))
    (let ((rand_init (list (lngp)))
          (return ()))
      (define (update)
        (if (null? n)
          (if (= (length rand_init) 100)
            (begin (set! return rand_init)
                   (set! rand_init (list (lngp)))
                   (cons 'quote (list return)))
            (begin (set! rand_init (cons (lngp) rand_init))
                   (update)))
          (if (= (length rand_init) (car n))
            (begin (set! return rand_init)
                   (set! rand_init (list (lngp)))
                   (cons 'quote (list return)))
            (begin (set! rand_init (cons (lngp) rand_init))
                   (update)))))
      update)))

;generate lists of symbols
(define (ls-gen)
  (define sg (s-gen))
  (let ((rand_init (list (sg))))
    (define (update)
      (set! rand_init (cons (sg) rand_init)))
    update))

;tool for generating lists of numbers, symbols, and predicates.
(define (l-gen-pre)
  (define ng (n-gen))
  (define sg (s-gen))
  (define ng_index (n>0-gen))
  (let ((rand_init (ng))
        (n (ng_index)))
    (define (update)
      (cond ((= (remainder n 2) 0) 
             (set! n (ng_index))
             (set! rand_init (ng)))
            ((= (remainder n 2) 1) 
             (set! n (ng_index))
             (set! rand_init (sg)))))
    update))

;generate list of numbers, symbols, and predicates
(define (l-gen . n)
  (let ((lgp (l-gen-pre)))
    (let ((rand_init (list (lgp)))
          (return ()))
      (define (update)
        (if (null? n)
          (if (= (length rand_init) 100)
            (begin (set! return rand_init)
                   (set! rand_init (list (lgp)))
                   (cons 'quote (list return)))
            (begin (set! rand_init (cons (lgp) rand_init))
                   (update)))
          (if (= (length rand_init) (car n))
            (begin (set! return rand_init)
                   (set! rand_init (list (lgp)))
                   (cons 'quote (list return)))
            (begin (set! rand_init (cons (lgp) rand_init))
                   (update)))))
      update)))

;generates either number, symbol, predicate, or list
(define (x-gen)
  (define ng (n-gen))
  (define sg (s-gen))
  (define pg (p-gen))
  (define lg (l-gen))
  (define ng_index (n>0-gen))
  (let ((rand_init (ng))
        (n (ng_index)))
    (define (update)
      (cond ((= (remainder n 4) 0)
             (set! n (ng_index))
             (set! rand_init (ng)))
            ((= (remainder n 4) 1)
             (set! n (ng_index))
             (set! rand_init (sg)))
            ((= (remainder n 4) 2)
             (set! n (ng_index))
             (set! rand_init (pg)))
            ((= (remainder n 4) 3)
             (set! n (ng_index))
             (set! rand_init (lg)))))
    update))

;generate a list of 100 elements of type element.
(define (...-gen)
  (define ng (n-gen))
  (define n>0g (n>0-gen))
  (define n!=0g (n!=0-gen))
  (define pg (p-gen))
  (define lg (l-gen))
  (define xg (x-gen))
  (define (run-and-list n proc)
    (if (= n 0)
      ()
      (cons (proc) (run-and-list (- n 1) proc))))
  ;just default to 100 elements of type ...
  (define (get-value element)
    (cond ((eq? element 'n)
           (run-and-list 100 ng))
          ((eq? element 'n>0)
           (run-and-list 100 n>0g))
          ((eq? element 'n!=0)
           (run-and-list 100 n!=0g))
          ((eq? element 'P)
           (run-and-list 100 pg))
          ((eq? element 'L)
           (run-and-list 100 lg))
          ((eq? element 'x)
           (run-and-list 100 xg))))
  get-value)

;======================QUEUE AND TABLE======================
;simple 1d queue for get procedure of store, and installer.
(define (make-queue)
  (let ((queue (cons () ())))
    (define (front-ptr) (car queue))
    (define (rear-ptr) (cdr queue))
    (define (set-front-ptr! item)
      (set-car! queue item))
    (define  (set-rear-ptr! item)
      (set-cdr! queue item))
    (define (empty-queue?)
      (null? (front-ptr)))
    (define (front-queue)
      (if (empty-queue?)
        (error "FRONT called with an empty queue" queue)
        (car (front-ptr))))
    (define (insert-queue! item)
      (let ((new-pair (cons item ())))
        (cond ((empty-queue?)
               (set-front-ptr! new-pair)
               (set-rear-ptr! new-pair)
               queue)
              (else (set-cdr! (rear-ptr) new-pair)
                    (set-rear-ptr! new-pair)
                    queue))))
    (define (delete-queue!)
      (cond ((empty-queue?)
             (error "DELETE! called with an empty queue" queue))
            (else (set-front-ptr! (cdr (front-ptr)))
                  queue)))
    (define (print-queue)
      (display (front-ptr)))
    (define (dispatch m)
      (cond ((eq? m 'empty-queue?) (empty-queue?))
            ((eq? m 'front-queue) (front-queue))
            ((eq? m 'insert!) insert-queue!)
            ((eq? m 'delete!) (delete-queue!))
            ((eq? m 'print) (print-queue))
            (else (error "Unknown operation: QUEUE" m))))
    dispatch))

;simple method that'll be used for get-procs
(define (list->queue L)
  (let ((queue (make-queue)))
    (define (recursively lis)
      (if (null? lis)
        queue
        (begin ((queue 'insert!) (car lis))
               (recursively (cdr lis)))))
    (recursively L)))



(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup keys)
      (define (table-traverser ks table)
        (let ((key (car ks)))
          (if (null? (cdr ks))
            (let ((record (assoc key (cdr table))))
              (if record
                (cdr record)
                #f))
            (let ((subtable
                    (assoc key (cdr table))))
              (if subtable
                (table-traverser (cdr ks) subtable)
                #f)))))
      (table-traverser keys local-table))
    (define (insert! keys value)
      (define (make-piece ks v)
        (if (null? (cdr ks))
          (cons (car ks) v)
          (list (car ks) (make-piece (cdr ks) v))))
      (define (table-traverser ks v table)
        (let ((key (car ks)))
          (if (null? (cdr ks))
            (if (not (pair? (cdr table)))
              (set-cdr! table (list (cons key value)))
              (let ((record (assoc key (cdr table))))
                (if record
                  (set-cdr! record value)
                  (set-cdr! table
                            (cons (cons key value)
                                  (cdr table))))))
            (let ((subtable
                    (assoc key (cdr table))))
              (if subtable
                (table-traverser (cdr ks) value subtable)
                (set-cdr! table
                          (cons (make-piece ks value) (cdr table))))))))
      (begin (table-traverser keys value local-table)
             'ok))
    (define (query keys)
      (define (recursive-search keys result)
        (cond ((false? result) false)
              ((null? keys) result)
              (else 
                (let ((key (car keys)))
                  (recursive-search (cdr keys) (assoc key (cdr result)))))))
      (if (pair? keys)
        (recursive-search (cdr keys) (assoc (car keys) (cdr local-table)))
        (assoc keys (cdr local-table))))

    (define (print-table)
      (display local-table))
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            ((eq? m 'query) query)
            ((eq? m 'print-table) (print-table))
            (else (error "Unknown operation: TABLE" m))))
    dispatch))


;==================REPRESENTING PROCEDURES AND ENVIRONMENTS========================
;Procedure representation:
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))

(define (procedure-body p) (caddr p))

(define (procedure-environment p) (cadddr p))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc))) primitive-procedures))

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme (primitive-implementation proc) args))

;Environment representation:
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
    (cons (make-frame vars vals) base-env)
    (if (< (length vars) (length vals))
      (error "Too many arguments supplied" vars vals)
      (error "Too few arguments supplied" vars fals))))
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
      (error "Didn't find variable:" var)
      (let ((frame (first-frame env)))
        (let ((vars (frame-variables frame))
              (vals (frame-values frame)))
          (scan vars vals)))))
  (env-loop env))
(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
      (error "Unbound variable: SET!" var)
      (let ((frame (first-frame env)))
        (scan (frame-variables frame)
              (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame) (frame-values frame))))


(define (setup-environment)
  (let ((initial-env
          (extend-environment (primitive-procedure-names)
                              (primitive-procedure-objects)
                              the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))


;=========THE FIRST EVALUATOR TO BE TESTED=========

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure (lambda-parameters exp) (lambda-body exp) env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else 
          (error "Unknown expression type: EVAL" exp))))
;save a copy of the apply procedure implemented in scheme.
(define apply-in-underlying-scheme
  apply)
;implement the metacircular evaluator apply procedure.
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
          (error
            "Unknown procedure type: APPLY" procedure))))
(define (list-of-values exps env)
  (if (no-operands? exps)
    ()
    (cons (eval (first-operand exps) env)
          (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
    (eval (if-consequent exp) env)
    (eval (if-alternative exp) env)))
(define (eval-sequence exps env)
  (cond ((last-exp? exps)
         (eval (first-exp exps) env))
        (else
          (eval (first-exp exps) env)
          (eval-sequence (rest-exps exps) env))))
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)

;The only self-evaluating items are numbers and strings:
(define (self-evaluating? exp)
  (cond ((number? exp) #t)
        ((string? exp) #t)
        (else #f)))
;Varaibles are represented by symbols
(define (variable? exp) (symbol? exp))
;Quotations have the form (quote <text-of-quotation>)
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
;quoted? is defined in terms of the procedure tagged-list?, which identifies lists beginning with a designated symbol:
(define (tagged-list? exp tag)
  (if (pair? exp)
    (eq? (car exp) tag)
    #f))
;Assignments have the form (set! <var> <val>)
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
;Definitions have the form
;(define <var> <value>) or
;(define (<var> <parameter_1> ... <parameter_n>) <body>)
;The latter form is syntactic sugar for
;(define <var>
;  (lambda (<parameter_1>...<parameter_n>)
;    <body>))
;The corresponding syntax procedures are the following:
(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
    (cadr exp)
    (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
    (caddr exp)
    (make-lambda (cdadr exp) ;formal params
                 (cddr exp)))) ;body
;lambda expressions are lists that begin with the symbol lambda
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
;We also provide a constructor for lambda expressions, whic his used by definition-value above:
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
;Conditionals begin with if and have a predicate, a consequent, and an alternative. 
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
    (cadddr exp)
    'false))
;We provide a constructor for if expressions, used by cond->if to transform `cond` expressions to `if` expressions:
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
;begin packages a seq  of expressions into a single expression. We incldue syntax operations on begin expressions to extract the actual sequence from the begin expression, as well as selectors that return the first expression and the rest of the expressions in the sequence.
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
;We also include a constructor sequence->exp (for use by cond->if) that transforms a seq into a single exp, using begin if necessary:
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
;A procedure application is any compound expression that is not one of the above expression types. The car of the expression is the operator, and the cdr is the list of operands.
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
;We include syntax procedures that extract the parts of a cond expression, and a procedure cond->if that transforms cond expressions into if expressions.
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp) (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
    'false
    (let ((first (car clauses))
          (rest (cdr clauses)))
      (if (cond-else-clause? first)
        (if (null? rest)
          (sequence->exp (cond-actions first))
          (error "ELSE clause isn't last: COND->IF" clauses))
        (make-if (cond-predicate first)
                 (sequence->exp (cond-actions first))
                 (expand-clauses rest))))))

;=========THE SECOND EVALUATOR TO BE TESTED=========

(define (eval-after-analyze exp env) ((analyze exp) env))

(define (analyze exp)
  (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else (error "Unknown expression type: ANALYZE" exp))))

;Self evaluating expression
(define (analyze-self-evaluating exp)
  (lambda (env) exp))

;Quoted expression
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))

;Variable expression (lookup of variable depends on environment so done in execution step)
(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))

;Assignment expression 

(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))

;if expressions

(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env) (if (true? (pproc env))
                    (cproc env)
                    (aproc env)))))

;lambda expressions

(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))


;sequence expressions
;Takes (exp1 exp2 ... expn) and outputs (lambda (env) (lambda (env) (... (lambda (env) (exp1 env) (exp2 env)) ...) (expn-1 env)) (expn env))
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
      first-proc
      (loop (sequentially first-proc (car rest-procs))
            (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs) (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))

;application expressions
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application
        (fproc env)
        (map (lambda (aproc) (aproc env))
             aprocs)))))
;execute-apply is analog of apply in this new system
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
            (procedure-parameters proc)
            args
            (procedure-environment proc))))
        (else 
          (error "Unknown procedure type: EXECTUE-APPLICATION"
                 proc))))


;============================PKG AND STORE STUFF============================

;pkg constructor
(define (pkg name param_types proc eval)
  (if (tagged-list? proc 'primitive)
    (cons (list 'primitive name) (cons param_types (lambda (env) (define-variable! name proc env) 'ok)))
    (cons (list 'non-primitive name) (cons param_types (lambda (env) (eval proc env) 'ok)))))
;pkg selectors 
(define (pkg-keys _pkg)
  (car _pkg))
(define (pkg-data _pkg)
  (cdr _pkg))
;pkg setters
(define (set-pkg-keys! _pkg keys)
  (set-car! _pkg keys))
(define (set-pkg-proc!  _proc)
  (if (tagged-list? _proc 'primitive)
    (set-cdr! (pkg-data _pkg)  (lambda (env) (define-variable! name _proc env) 'ok))
    (set-cdr! (pkg-data _pkg) (lambda (env) (eval _proc env) 'ok))))

;store constructor
(define (make-store eval)
  (let ((procs (make-table)))
    (define (query-procs query)
      ((procs 'query) query))

    (define (update _pkg)
      (let ((name:data (query-procs (pkg-keys _pkg))))
        (if name:data
          (let ((data (cdr name:data)))
            (if (not (equal? (pkg-data _pkg) data))
              (set-cdr! name:data (pkg-data _pkg))))
          ((procs 'insert!) (pkg-keys _pkg) (pkg-data _pkg)))))

    (define (add-pkg name param_types proc)
      (update (pkg name param_types proc eval)))


    (define (print-procs)
      (procs 'print-table))

    (define (initialize-primitives)
      (define (initialize-primitive-arithmetic)
        (add-pkg '= '(n n) (list 'primitive =))
        (add-pkg '+ '(n ...) (list 'primitive +))
        (add-pkg '- '(n ...) (list 'primitive -))
        (add-pkg '* '(n ...) (list 'primitive *))
        (add-pkg '/ '(n!=0 ...) (list 'primitive /))
        (add-pkg 'log '(n>0) (list 'primitive log))
        'ok)
      (define (initialize-primitive-modular-arithmetic)
        (add-pkg 'remainder '(n n) (list 'primitive remainder))
        (add-pkg 'quotient '(n n!=0) (list 'primitive quotient))
        (add-pkg 'modulo '(n n!=0) (list 'primitive modulo))
        'ok)
      (define (initialize-primitive-boolean)
        (add-pkg 'not '(x) (list 'primitive not))
        'ok)

      (define (initialize-primitive-relations)
        (add-pkg '< '(n n) (list 'primitive <))
        (add-pkg '<= '(n n) (list 'primitive <=))
        (add-pkg '> '(n n) (list 'primitive >))
        (add-pkg '>= '(n n) (list 'primitive >=))
        (add-pkg 'eq? '(x x) (list 'primitive eq?))
        (add-pkg 'number? '(x) (list 'primitive number?))
        (add-pkg 'symbol? '(x) (list 'primitive symbol?))
        (add-pkg 'pair? '(x) (list 'primitive pair?))
        'ok)
      (define (initialize-primitive-list)
        (add-pkg 'length '(L) (list 'primitive length)))

      (initialize-primitive-arithmetic)
      (initialize-primitive-modular-arithmetic)
      (initialize-primitive-boolean)
      (initialize-primitive-relations)
      (initialize-primitive-list))
    (define (initialize-non-primitives)
      (add-pkg 'inc '(n) '(define (inc x) (+ x 1)))
      (add-pkg 'dec '(n) '(define (dec x) (- x 1)))
      (add-pkg 'identity '(x) '(define (identity x) x))
      (add-pkg 'square '(n) '(define (square x) (* x x)))
      (add-pkg 'cube '(n) '(define (cube x) (* x x x)))
      (add-pkg 'sum '(ln) '(define (sum args)
                             (define (iteratively args total)
                               (if (null? args)
                                 total
                                 (iteratively (cdr args) (+ total (car args)))))
                             (iteratively args 0)))
      (add-pkg 'average '(ln) '(define (average args) (/ (sum args) (length args))))
      (add-pkg 'logB '(n!=0 n) '(define (logB B x)
                                  (/ (log x) (log B))))
      (add-pkg 'fib '(20<n<25) '(define (fib n)
                                  (if (= n 0) 
                                    0
                                    (if (= n 1) 
                                      1
                                      (+ (fib (- n 1)) (fib (- n 2)))))))
      (add-pkg 'fact '(n>=0) '(define (fact n)
                                (if (= n 1) 1 (* n (fact (- n 1))))))
      ;**boolean procedures**
      (add-pkg 'false? '(x) '(define (false? x) (eq? x false)))

      (add-pkg 'true? '(x) '(define (true? x) (not (false? x))))

      (add-pkg 'and '(x x) '(define (and p1 p2)
                              (if (true? p1)
                                (if (true? p2) ;                       true
                                  false)
                                false)))
      (add-pkg'or '(x x) '(define (or p1 p2)
                            (if (true? p1)
                              true
                              (if (true? p2)
                                true
                                false))))
      (add-pkg 'number-list? '(L) '(define (number-list? input)
                                     (if (number? input) 
                                       true
                                       (if (symbol? input) 
                                         false
                                         (if (pair? input) 
                                           (and (number? (car input)) (number-list? (cdr input)))
                                           true)))))
      ;**pair procedures** 
      (add-pkg 'append '(L L) '(define (append x y)
                                 (if (null? x) 
                                   y 
                                   (cons (car x) (append (cdr x) y)))))
      ;(add-pkg 'map '(f L) '(define (map proc . args)
      ;                              (define (mini-map proc arg)
      ;                                (if (null? arg)
      ;                                  ()
      ;                                  (cons (proc (car arg)) (mini-map proc (cdr arg)))))
      ;                              (define (map-proc proc . args)
      ;                                (if (null? args)
      ;                                  ()
      ;                                  (cons (mini-map proc (car args)) (map-proc proc (cdr args)))))
      ;                              map-proc))    
      (add-pkg 'filter '(P L) '(define (filter pred? L)
                                 (if (null? L) 
                                   '()
                                   (if (pred? (car L)) 
                                     (cons (car L) (filter pred? (cdr L)))
                                     (filter pred? (cdr L))))))
      'ok)
    (initialize-primitives)
    (initialize-non-primitives)
    (define (dispatch m)
      (cond ((eq? m 'add) add-pkg)
            ((eq? m 'query) query-procs)
            ((eq? m 'print) (print-procs))
            (else ("Sorry, I don't understand MESSAGE: " m))))
    dispatch))     

;=====================INSTALLER STUFF=====================
(define (make-installer store env)
  (define (data->queue data)
    (list->queue (map (lambda (x) (cdr x)) data)))
  (define (get-all-data)
    (data->queue (append (cdr ((store 'query) 'primitive)) (cdr ((store 'query) 'non-primitive)))))
  (define (get-primitives)
    (data->queue (cdr ((store 'query) 'primitive))))
  (define (get-non-primitives)
    (data->queue (cdr ((store 'query) 'non-primitive))))
  (define (install data_queue env)
    (if (not (data_queue 'empty-queue?))
      (let ((proc (cdr (data_queue 'front-queue))))
        (proc env)
        (data_queue 'delete!)
        (install data_queue env))
      'done))
  (define (dispatcher m)
    (cond ((eq? m 'a)
           (install (get-all-data) env))
          ((eq? m 'p)
           (install (get-primitives) env))
          ((eq? m 'c)
           (install (get-non-primitives) env))))
  dispatcher)
;===================TESTING===================

(define (timing-procedures)
  (define (timer run apps)
    (let ((start_time (runtime)))
      (run apps)
      (- (runtime) start_time)))
  (define (difference time1 time2)
    (/ (- time2 time1) time1))
  (define (dispatch m)
    (cond ((eq? m 'timer) timer)
          ((eq? m 'difference) difference)))
  dispatch)

(define (make-tester eval)
  (let ((store (make-store eval))
        (env (setup-environment)))
    (let ((installer (make-installer store env)))
      (installer 'a)
      (let ((ng (n-gen))
            (n!=0g (n!=0-gen))
            (n>0g (n>0-gen))
            (n>=0g (n>=0-gen))
            (n<0g (n<0-gen))
            (20<n<25g (20<n<25-gen))
            (pg (p-gen))
            (lg (l-gen))
            (lng (ln-gen))
            (xg (x-gen))
            (...g (...-gen)))
        (installer 'a)
        (define name:param_types
          (map (lambda (x) (cons (car x) (cadr x)))
               (append (cdr ((store 'query) 'primitive))
                       (cdr ((store 'query) 'non-primitive)))))
        ;param_types:n n!=0 n<0 n<=0 n>0 n>=0 x P L ...
        (define (args-gen param_types)
          (cond ((null? param_types) ())
                ((not (null? (cdr param_types)))
                 (if (eq? (cadr param_types) '...)
                   (let ((...g (...-gen)))
                     (...g (car param_types)))
                   (cons (arg-gen (car param_types)) (args-gen (cdr param_types)))))
                (else 
                  (cons (arg-gen (car param_types)) (args-gen (cdr param_types))))))
        (define (arg-gen param_type)
          (cond ((eq? param_type 'n) (ng))
                ((eq? param_type 'n!=0) (n!=0g))
                ((eq? param_type 'n>0) (n>0g))
                ((eq? param_type 'n>=0) (n>=0g))
                ((eq? param_type 'n<0) (n<0g))
                ((eq? param_type '20<n<25) (20<n<25g))
                ((eq? param_type 'P) (pg))
                ((eq? param_type 'L) (lg))
                ((eq? param_type 'Ln) (lng))
                ((eq? param_type 'x) (xg))))
        (define (name:param_type->app n:pt)
          (cons (car n:pt) (args-gen (cdr n:pt))))
        (define (name:param_types->apps ns:pts)
          (map name:param_type->app ns:pts))
        (define (app-gen name param_types)
          (cons name (args-gen param_types)))
        (define (apps-gen name param_types n)
          (if (= n 0)
            ()
            (cons (app-gen name param_types) (apps-gen name param_types (- n 1)))))
        (define (run-applications applications)
          (if (null? applications)
            'done
            (let ((application (car applications)))
              (eval application env)
              (run-applications (cdr applications)))))
        (define (test)
          (let ((apps (name:param_types->apps name:param_types))
                (start_time (runtime)))
            (run-applications apps)
            (let ((time (- (runtime) start_time)))
              (newline)
              (display "Time to run procedures: ")
              (display time)
              (newline)
              time)))
        (define (dispatch m)
          (if (eq? m 'test) 
            (test)))
        dispatch))))

;===========================Initialization===========================

(define tester1 (make-tester eval))
(define t1 (tester1 'test))

(define tester2 (make-tester eval-after-analyze))
(define t2 (tester2 'test))

;to do: handle map argument generation.

;If we assume that the additional time that the second interpreter takes is due to analyzing on each execution, 
;we could say the percentage of time spent analyzing syntax for various procedures is:
(define t3 (* 100 (/ (- t1 t2) t2)))
